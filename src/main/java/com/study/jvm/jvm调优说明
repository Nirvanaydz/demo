java -XX:+PrintFlagsFinal

-XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation


CMS并发标记算法：垃圾回收和线程运行同时进行，区别于serial和serial old，
停止线程的运行，然后进行垃圾回收。
存在的问题就是错标和漏标
漏标：这个对象垃圾回收器未标记，但是过了一会变成了垃圾，漏标了这个对象，浮动垃圾
错标：就是垃圾回收器已经标记了对象为垃圾，但是突然进来一个线程重新引用指向到这个对象，那就是错标
		这是一个很严重的问题！【初始，并发标记，重新标记（如何进行重新标记），最后进行并发清理】

并发标记算法：(三色标记算法)
    白色：未被标记的对象
    灰色：自身被标记，成员变量未被标记
    黑色：自身和成员变量均被标记（成员变量被标记，不代表成员变量标记完成？是这么理解吗？）

    第一种情况说明：（在垃圾回收中，未被标记的对象将会被回收）
        初始状态：有一个引用指向方式
            A（黑色：自己标记完成，其成员变量也标记完成）-->B（灰色，自己未标记完成）-->D（还未被标记）
        异常：程序运行时，B指向D的引用消失了，导致D对象未被标记完成，这时运行过程中A对象又产生一个新的引用指向D，
            但是我们认为A已经标记完成，就不会标记D了，这就是错标
            （标记中，但是不表示B标记完成了）B<--A（但是A已被标为黑色）-->（新增指向）D（未被标记）
        处理方法：将A重新标记remake为灰色（incremental update），CMS采用重新扫描的方式
        （但是有些扫描已经完成，保存在扫描中了，所以耗时没有第一次那么长）

java - 标准参数
     -X 非标参数
     -XX 每一个GC回收器都不一样

     java -Xms200M -Xmx200M -XX:+PrintGC com.study.jvm.chapter2_runningDataArea.FullGCProblem01